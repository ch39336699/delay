package com.fedex.intl.cd.data;
// Generated Class:         MsgId
// Generated on:            Tue Nov 20 15:08:37 MST 2018
// Generated by:            339143
// Generated on OS:         Windows 8.1
// Generated on OS Version: 6.3
// Generated on VM:         Java HotSpot(TM) Client VM
// Generated on VM Vendor:  Oracle Corporation
// Generated on VM Version: 25.31-b07
// Generated by Component:  rmtc.stateGenerator.StateGenerator
// State Generater Version: $Revision: 39958 $
// State Version:           null

//-------------------------------------------------------------------
//  Below is the input fragment that was parsed to generate this file
//-------------------------------------------------------------------
//<xml-fragment generate="true" type="MsgId" packageName="com.fedex.intl.cd.data">
//  <stat:Attribute getterName="getMsgId" setterName="setMsgId" name="MsgId" type="long" fieldID="3001" xmlns:stat="file://rmtc/stateGenerator/StateConfig"/>
//  <stat:Attribute getterName="getDelayTm" setterName="setDelayTm" name="DelayTm" type="long" fieldID="3004" xmlns:stat="file://rmtc/stateGenerator/StateConfig"/>
//</xml-fragment>
//-------------------------------------------------------------------
/**
 */
public abstract class MsgIdBase extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable, Comparable, rmtc.util.TemplateParserDataSourceInterface
{

    /**
     *  Field MsgId
     */
    private long m_MsgId;

    /**
     *  Field DelayTm
     */
    private long m_DelayTm;
    // Object References; there are  0 Objects
    //Constructors for class

    // Getters/Setters for field:  MsgId
    /**
     *  Getter for field:  MsgId
     *
     * @return long
     */
    public long getMsgId()
    {
        return this.m_MsgId;
    }
    /**
     *  Setter for field:  MsgId
     *
     * @param arg1 a long Value that the field should be set to..
     */
    public void setMsgId(long arg1)
    {
        this.m_MsgId = arg1;
        return;
    }

    // Getters/Setters for field:  DelayTm
    /**
     *  Getter for field:  DelayTm
     *
     * @return long
     */
    public long getDelayTm()
    {
        return this.m_DelayTm;
    }
    /**
     *  Setter for field:  DelayTm
     *
     * @param arg1 a long Value that the field should be set to..
     */
    public void setDelayTm(long arg1)
    {
        this.m_DelayTm = arg1;
        return;
    }

    /**
     *  Used for debuging Data object contents
     *
     * @return String String that is a Human readable representation of the data in this object
     */
    public String toString()
    {
        return toFormattedString(0,10);
    }

    /**
     *  Used for debuging and allowing child classes data to indent the same as the parents data
     *
     * @param indentSize a int Number of spaces to indent the region.
     * @return String String that is a Human readable representation of the data in this object
     */
    public String toFormattedString(int indentSize)
    {
        return toFormattedString(indentSize,10);
    }

    /**
     *  Used for debuging and allowing child classes data to indent the same as the parents data
     *
     * @param indentSize a int Number of spaces to indent the region.
     * @param minNameLen a int The minimum column size to use for the name column.
     * @return String String that is a Human readable representation of the data in this object
     */
    public String toFormattedString(int indentSize,int minNameLen)
    {
        String spaces = "                                                                                                                                                                                                                              ";
        //Normal Case, so dont call super.toFormattedString()
        String indent = null;
        if(indentSize >= 0)
        {
            indent = spaces.substring(0,indentSize);
        }
        StringBuffer retVal = new StringBuffer();
        retVal.append("Instance of MsgId\n");
        if(indent != null)
        {
            indent += "  ";
        }
        if(minNameLen < 10)
        {
            minNameLen = 10;
        }
        if(indent != null) retVal.append(indent);
        retVal.append("MsgId:");
        if(minNameLen > 6)
        {
            retVal.append(spaces.substring(0,(minNameLen - 6)));
        }
        retVal.append(this.getMsgId());
        retVal.append("\n");
        if(indent != null) retVal.append(indent);
        retVal.append("DelayTm:");
        if(minNameLen > 8)
        {
            retVal.append(spaces.substring(0,(minNameLen - 8)));
        }
        retVal.append(this.getDelayTm());
        retVal.append("\n");

        retVal.append("\n");

        return retVal.toString();
    }

    /**
     *  Creates and returns a copy of this object;  This method does a "deep" clone instead of the default "shallow" clone that is implemented by default
     *
     * @return Object A clone of this object
     */
    public Object clone()
    {
        MsgIdBase copy = null;
        try
        {
            copy = (MsgIdBase)super.clone();
        }
        catch(Exception e)
        {
            throw new InternalError("Failed to \"deep\" clone class:  MsgIdBase:  " + e);
        }

        //Skipping Primitive/String MsgId
        //Skipping Primitive/String DelayTm

        return copy;
    }


    // This is the code to implement the rmtc.util.TemplateParserDataSourceInterface interface


    /**
     *  Returns the template translation key object
     *
     * @param key a String String key to be converted to an object.
     * @return Object Key Value for TemplateParser
     */
    public Object getTemplateTranslationKeyObject(String key)
    {
        return null;
    }

    /**
     *  Returns the template translation value
     *
     * @param key a Object Key to get the value of.
     * @return String Value from object based on key
     */
    public String getTemplateTranslation(Object key)
    {
        String retVal = "";
        Object retObject = null;
        if(key != null)
        {
            {
                Integer iKey = (Integer)key;
                retObject = getContainedField(iKey.intValue());
            }
            if(retObject != null)
            {
                retVal = retObject.toString();
            }
        }
        return retVal;
    }

    /**
     *  This method is for working on sub object equality
     *
     * @param o1 a Object Object 1.
     * @param o2 a Object Object 2.
     * @return boolean equality
     */
    protected boolean objEquals(Object o1,Object o2)
    {
        boolean retVal = false;
        if(o1 == null)
        {
            if(o2 == null)
            {
                retVal = true;
            }
        }
        else
        {
            if(o2 != null)
            {
                retVal = o1.equals(o2);
            }
        }
        return retVal;
    }
    /**
     *  This method implements the equals/hashCode contract for the data object
     *
     * @return int an integer representation of this object
     */
    public int hashCode()
    {
        int retVal = -1109916915; // You have to start somewhere, so why not here
        retVal += (new Long(this.getMsgId())).hashCode();
        retVal += (new Long(this.getDelayTm())).hashCode();
        return retVal;
    }
    /**
     *  Method to determine equality of this object and the argument.
     *
     * @param inObj a Object Object to compare against this one.
     * @return boolean equality of the objects
     */
    public boolean equals(Object inObj)
    {
        if((inObj == null) || (this.getClass().equals(inObj.getClass()) == false))
        {
            return false;
        }
        MsgId obj = (MsgId)inObj;
        return true
                && (this.getMsgId() == obj.getMsgId())
                && (this.getDelayTm() == obj.getDelayTm())
                ;
    }
    /**
     *  This method compares this object to the passed object
     *
     * @param o a Object Object to compare myself to.
     * @return int indicator (<0,0,>0) of how the two objects compare
     */
    public int compareTo(Object o)
    {
        MsgId lo = (MsgId)o;
        int retVal = 0;
        do
        {
//      Make the comparison for field:  m_MsgId with comparable order id:  627
            retVal = (int)(m_MsgId - lo.getMsgId());
            if(retVal != 0)
            {
                break;
            }
//      Make the comparison for field:  m_DelayTm with comparable order id:  628
            retVal = (int)(m_DelayTm - lo.getDelayTm());
            if(retVal != 0)
            {
                break;
            }
        } while(false);
        return retVal;
    }
//  Now write all the constant FIELDID definitions
    /**
     *  Constant for field MsgId of type: long
     */
    public static final int MSG_ID_FIELDID = 3001;
    /**
     *  Constant for field DelayTm of type: long
     */
    public static final int DELAY_TM_FIELDID = 3004;
    /**
     *  Returns the appropriate Object by Field ID
     *
     * @param fieldID a int Field ID to get the value of.
     * @return Object The appropriate Object by field ID
     */
    public Object getContainedField(int fieldID)
    {
        Object retVal = null;
        // Switch Statement for the classes's 2 Member Variables
        switch(fieldID)
        {
            // Case for -1
            case -1:
                retVal = this;
                break;
            //  Case for MsgId
            case MSG_ID_FIELDID:
                // primitive:  long
                retVal = new Long(getMsgId());
                break;
            //  Case for DelayTm
            case DELAY_TM_FIELDID:
                // primitive:  long
                retVal = new Long(getDelayTm());
                break;
            default:
//      inheritedFromClassSupportsGeneratedMethods:  false
//      Since this class does not inherit from a generated class, don't call super.
                throw new RuntimeException("FieldID " + fieldID + " not supported by Object:  " + this.getClass().getName());
        }

        return retVal;
    }

    /**
     *  Sets the appropriate field to the inputted value
     *
     * @param fieldID a int Field ID to set.
     * @param fieldStrValue a String String value of field.
     */
    public void setContainedField(int fieldID,String fieldStrValue)
    {
        //This is to make sure we are getting here!!!
        switch(fieldID)
        {
            case -1:
                throw new RuntimeException("field ID of -1 not allowed to setContainedField()");
                //  break;  //This is unreachable, so commented out
                //  Case for MsgId
            case MSG_ID_FIELDID:
                // primitive:  long
                setMsgId(Long.parseLong(fieldStrValue));
                break;
            //  Case for DelayTm
            case DELAY_TM_FIELDID:
                // primitive:  long
                setDelayTm(Long.parseLong(fieldStrValue));
                break;
            default:
//      inheritedFromClassSupportsGeneratedMethods:  false
//      Since this class does not inherit from a generated class, don't call super.
                throw new RuntimeException("FieldID " + fieldID + " not supported by Object:  " + this.getClass().getName());
        }
    }

    /**
     *  Sets the appropriate field to the inputted value
     *
     * @param fieldID a int Field ID to set.
     * @param fieldValue a Object Object value of field.
     */
    public void setContainedFieldObject(int fieldID,Object fieldValue)
    {
        switch(fieldID)
        {
            case -1:
                throw new RuntimeException("field ID of -1 not allowed to setContainedField()");
                //  break;  //This is unreachable, so commented out
                //  Case for MsgId
            case MSG_ID_FIELDID:
                // primitive:  long
                setMsgId(((Long)fieldValue).longValue());
                break;
            //  Case for DelayTm
            case DELAY_TM_FIELDID:
                // primitive:  long
                setDelayTm(((Long)fieldValue).longValue());
                break;
            default:
//      inheritedFromClassSupportsGeneratedMethods:  false
//      Since this class does not inherit from a generated class, don't call super.
                throw new RuntimeException("FieldID " + fieldID + " not supported by Object:  " + this.getClass().getName());
        }
    }

}
